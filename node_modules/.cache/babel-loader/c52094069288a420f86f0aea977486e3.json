{"ast":null,"code":"var clone = function () {\n  'use strict';\n\n  function _instanceof(obj, type) {\n    return type != null && obj instanceof type;\n  }\n\n  var nativeMap;\n\n  try {\n    nativeMap = Map;\n  } catch (_) {\n    // maybe a reference error because no `Map`. Give it a dummy value that no\n    // value will ever be an instanceof.\n    nativeMap = function () {};\n  }\n\n  var nativeSet;\n\n  try {\n    nativeSet = Set;\n  } catch (_) {\n    nativeSet = function () {};\n  }\n\n  var nativePromise;\n\n  try {\n    nativePromise = Promise;\n  } catch (_) {\n    nativePromise = function () {};\n  }\n  /**\n   * Clones (copies) an Object using deep copying.\n   *\n   * This function supports circular references by default, but if you are certain\n   * there are no circular references in your object, you can save some CPU time\n   * by calling clone(obj, false).\n   *\n   * Caution: if `circular` is false and `parent` contains circular references,\n   * your program may enter an infinite loop and crash.\n   *\n   * @param `parent` - the object to be cloned\n   * @param `circular` - set to true if the object to be cloned may contain\n   *    circular references. (optional - true by default)\n   * @param `depth` - set to a number if the object is only to be cloned to\n   *    a particular depth. (optional - defaults to Infinity)\n   * @param `prototype` - sets the prototype to be used when cloning an object.\n   *    (optional - defaults to parent prototype).\n   * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n   *    should be cloned as well. Non-enumerable properties on the prototype\n   *    chain will be ignored. (optional - false by default)\n  */\n\n\n  function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n    if (typeof circular === 'object') {\n      depth = circular.depth;\n      prototype = circular.prototype;\n      includeNonEnumerable = circular.includeNonEnumerable;\n      circular = circular.circular;\n    } // maintain two arrays for circular references, where corresponding parents\n    // and children have the same index\n\n\n    var allParents = [];\n    var allChildren = [];\n    var useBuffer = typeof Buffer != 'undefined';\n    if (typeof circular == 'undefined') circular = true;\n    if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren\n\n    function _clone(parent, depth) {\n      // cloning null always returns null\n      if (parent === null) return null;\n      if (depth === 0) return parent;\n      var child;\n      var proto;\n\n      if (typeof parent != 'object') {\n        return parent;\n      }\n\n      if (_instanceof(parent, nativeMap)) {\n        child = new nativeMap();\n      } else if (_instanceof(parent, nativeSet)) {\n        child = new nativeSet();\n      } else if (_instanceof(parent, nativePromise)) {\n        child = new nativePromise(function (resolve, reject) {\n          parent.then(function (value) {\n            resolve(_clone(value, depth - 1));\n          }, function (err) {\n            reject(_clone(err, depth - 1));\n          });\n        });\n      } else if (clone.__isArray(parent)) {\n        child = [];\n      } else if (clone.__isRegExp(parent)) {\n        child = new RegExp(parent.source, __getRegExpFlags(parent));\n        if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n      } else if (clone.__isDate(parent)) {\n        child = new Date(parent.getTime());\n      } else if (useBuffer && Buffer.isBuffer(parent)) {\n        if (Buffer.allocUnsafe) {\n          // Node.js >= 4.5.0\n          child = Buffer.allocUnsafe(parent.length);\n        } else {\n          // Older Node.js versions\n          child = new Buffer(parent.length);\n        }\n\n        parent.copy(child);\n        return child;\n      } else if (_instanceof(parent, Error)) {\n        child = Object.create(parent);\n      } else {\n        if (typeof prototype == 'undefined') {\n          proto = Object.getPrototypeOf(parent);\n          child = Object.create(proto);\n        } else {\n          child = Object.create(prototype);\n          proto = prototype;\n        }\n      }\n\n      if (circular) {\n        var index = allParents.indexOf(parent);\n\n        if (index != -1) {\n          return allChildren[index];\n        }\n\n        allParents.push(parent);\n        allChildren.push(child);\n      }\n\n      if (_instanceof(parent, nativeMap)) {\n        parent.forEach(function (value, key) {\n          var keyChild = _clone(key, depth - 1);\n\n          var valueChild = _clone(value, depth - 1);\n\n          child.set(keyChild, valueChild);\n        });\n      }\n\n      if (_instanceof(parent, nativeSet)) {\n        parent.forEach(function (value) {\n          var entryChild = _clone(value, depth - 1);\n\n          child.add(entryChild);\n        });\n      }\n\n      for (var i in parent) {\n        var attrs;\n\n        if (proto) {\n          attrs = Object.getOwnPropertyDescriptor(proto, i);\n        }\n\n        if (attrs && attrs.set == null) {\n          continue;\n        }\n\n        child[i] = _clone(parent[i], depth - 1);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(parent);\n\n        for (var i = 0; i < symbols.length; i++) {\n          // Don't need to worry about cloning a symbol because it is a primitive,\n          // like a number or string.\n          var symbol = symbols[i];\n          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n\n          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n            continue;\n          }\n\n          child[symbol] = _clone(parent[symbol], depth - 1);\n\n          if (!descriptor.enumerable) {\n            Object.defineProperty(child, symbol, {\n              enumerable: false\n            });\n          }\n        }\n      }\n\n      if (includeNonEnumerable) {\n        var allPropertyNames = Object.getOwnPropertyNames(parent);\n\n        for (var i = 0; i < allPropertyNames.length; i++) {\n          var propertyName = allPropertyNames[i];\n          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n\n          if (descriptor && descriptor.enumerable) {\n            continue;\n          }\n\n          child[propertyName] = _clone(parent[propertyName], depth - 1);\n          Object.defineProperty(child, propertyName, {\n            enumerable: false\n          });\n        }\n      }\n\n      return child;\n    }\n\n    return _clone(parent, depth);\n  }\n  /**\n   * Simple flat clone using prototype, accepts only objects, usefull for property\n   * override on FLAT configuration object (no nested props).\n   *\n   * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n   * works.\n   */\n\n\n  clone.clonePrototype = function clonePrototype(parent) {\n    if (parent === null) return null;\n\n    var c = function () {};\n\n    c.prototype = parent;\n    return new c();\n  }; // private utility functions\n\n\n  function __objToStr(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n  clone.__objToStr = __objToStr;\n\n  function __isDate(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object Date]';\n  }\n\n  clone.__isDate = __isDate;\n\n  function __isArray(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object Array]';\n  }\n\n  clone.__isArray = __isArray;\n\n  function __isRegExp(o) {\n    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n  }\n\n  clone.__isRegExp = __isRegExp;\n\n  function __getRegExpFlags(re) {\n    var flags = '';\n    if (re.global) flags += 'g';\n    if (re.ignoreCase) flags += 'i';\n    if (re.multiline) flags += 'm';\n    return flags;\n  }\n\n  clone.__getRegExpFlags = __getRegExpFlags;\n  return clone;\n}();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}","map":{"version":3,"sources":["/Users/xuyingwang/Documents/Pique-Lite/node_modules/clone/clone.js"],"names":["clone","_instanceof","obj","type","nativeMap","Map","_","nativeSet","Set","nativePromise","Promise","parent","circular","depth","prototype","includeNonEnumerable","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","resolve","reject","then","value","err","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","length","copy","Error","Object","create","getPrototypeOf","index","indexOf","push","forEach","key","keyChild","valueChild","set","entryChild","add","i","attrs","getOwnPropertyDescriptor","getOwnPropertySymbols","symbols","symbol","descriptor","enumerable","defineProperty","allPropertyNames","getOwnPropertyNames","propertyName","clonePrototype","c","__objToStr","o","toString","call","re","flags","global","ignoreCase","multiline","module","exports"],"mappings":"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","sourcesContent":["var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n"]},"metadata":{},"sourceType":"script"}